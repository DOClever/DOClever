"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var buildReducer_1 = require("../buildReducer");
var staticUnwrapper = function (action) { return action; };
describe('buildReducer', function () {
    it('should return an initial state when undefined state is provided', function () {
        var initialState = 42;
        var reducer = buildReducer_1["default"]([{
                unwrapper: staticUnwrapper,
                handler: function (state) { return state; }
            }], initialState);
        expect(reducer(undefined, { type: 'foobar' }))
            .toBe(initialState);
    });
    it('should provide unwrapped action as argument', function () {
        var actionType = 'UNWRAPPED';
        var reducer = buildReducer_1["default"]([{
                unwrapper: function (action) { return ({ type: actionType }); },
                handler: (function (state, _a) {
                    var type = _a.type;
                    return type;
                })
            }], '');
        expect(reducer(undefined, { type: 'bazbar' })).toBe(actionType);
    });
    it('should not call the handler if it does not unwrapper doesnt match the action', function () {
        var nonMatchingActionType = 'NonMatching';
        var matchingActionType = 'Matching';
        var initialState = 42;
        var reducer = buildReducer_1["default"]([{
                unwrapper: function (action) {
                    if (action.type === matchingActionType) {
                        return action;
                    }
                    else {
                        return null;
                    }
                },
                handler: function () { return 43; }
            }], initialState);
        expect(reducer(undefined, { type: nonMatchingActionType })).toBe(initialState);
        expect(reducer(undefined, { type: matchingActionType })).toBe(43);
    });
    it('should return original reference to the state when no action is handled', function () {
        var state = {};
        var reducer = buildReducer_1["default"]([{
                unwrapper: function (action) { return null; },
                handler: function (state) { return (__assign({}, state)); }
            }], state);
        expect(reducer(undefined, { type: 'foo' })).toBe(state);
    });
});
