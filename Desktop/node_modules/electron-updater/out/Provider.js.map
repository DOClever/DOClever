{"version":3,"file":"Provider.js","sourceRoot":"","sources":["../src/Provider.ts"],"names":[],"mappings":"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","sourcesContent":["import { CancellationToken, HttpExecutor, newError, safeStringifyJson, UpdateFileInfo, UpdateInfo, WindowsUpdateInfo } from \"builder-util-runtime\"\nimport { OutgoingHttpHeaders, RequestOptions } from \"http\"\nimport { safeLoad } from \"js-yaml\"\nimport { URL } from \"url\"\nimport { newUrlFromBase, ResolvedUpdateFileInfo } from \"./main\"\n\nexport abstract class Provider<T extends UpdateInfo> {\n  protected requestHeaders: OutgoingHttpHeaders | null = null\n\n  protected constructor(protected readonly executor: HttpExecutor<any>, readonly useMultipleRangeRequest = true) {\n  }\n\n  get fileExtraDownloadHeaders(): OutgoingHttpHeaders | null {\n    return null\n  }\n\n  setRequestHeaders(value: OutgoingHttpHeaders | null): void {\n    this.requestHeaders = value\n  }\n\n  abstract getLatestVersion(): Promise<T>\n\n  abstract resolveFiles(updateInfo: UpdateInfo): Array<ResolvedUpdateFileInfo>\n\n  httpRequest(url: URL, headers?: OutgoingHttpHeaders | null, cancellationToken?: CancellationToken) {\n    return this.executor.request(this.createRequestOptions(url, headers), cancellationToken)\n  }\n\n  protected createRequestOptions(url: URL, headers?: OutgoingHttpHeaders | null): RequestOptions {\n    const result: RequestOptions = {}\n    if (this.requestHeaders == null) {\n      if (headers != null) {\n        result.headers = headers\n      }\n    }\n    else {\n      result.headers = headers == null ? this.requestHeaders : {...this.requestHeaders, ...headers}\n    }\n\n    result.protocol = url.protocol\n    result.hostname = url.hostname\n    if (url.port) {\n      result.port = url.port\n    }\n    result.path = url.pathname + url.search\n    return result\n  }\n}\n\nexport function findFile(files: Array<ResolvedUpdateFileInfo>, extension: string, not?: Array<string>): ResolvedUpdateFileInfo | null | undefined  {\n  if (files.length === 0) {\n    throw newError(\"No files provided\", \"ERR_UPDATER_NO_FILES_PROVIDED\")\n  }\n\n  const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`))\n  if (result != null) {\n    return result\n  }\n  else if (not == null) {\n    return files[0]\n  }\n  else {\n    return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)))\n  }\n}\n\nexport function parseUpdateInfo(rawData: string | null, channelFile: string, channelFileUrl: URL): UpdateInfo {\n  if (rawData == null) {\n    throw newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, \"ERR_UPDATER_INVALID_UPDATE_INFO\")\n  }\n\n  let result: UpdateInfo\n  try {\n    result = safeLoad(rawData)\n  }\n  catch (e) {\n    throw newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, \"ERR_UPDATER_INVALID_UPDATE_INFO\")\n  }\n  return result\n}\n\nexport function getFileList(updateInfo: UpdateInfo): Array<UpdateFileInfo> {\n  const files = updateInfo.files\n  if (files != null && files.length > 0) {\n    return files\n  }\n\n  if (updateInfo.path != null) {\n    return [\n      {\n        url: updateInfo.path,\n        sha512: updateInfo.sha512,\n      },\n    ]\n  }\n  else {\n    throw newError(`No files provided: ${safeStringifyJson(updateInfo)}`, \"ERR_UPDATER_NO_FILES_PROVIDED\")\n  }\n}\n\nexport function resolveFiles(updateInfo: UpdateInfo, baseUrl: URL, pathTransformer: (p: string) => string = p => p): Array<ResolvedUpdateFileInfo> {\n  const files = getFileList(updateInfo)\n  const result: Array<ResolvedUpdateFileInfo> = files.map(fileInfo => {\n    if ((fileInfo as any).sha2 == null && fileInfo.sha512 == null) {\n      throw newError(`Update info doesn't contain nor sha256 neither sha512 checksum: ${safeStringifyJson(fileInfo)}`, \"ERR_UPDATER_NO_CHECKSUM\")\n    }\n    return {\n      url: newUrlFromBase(pathTransformer(fileInfo.url), baseUrl),\n      info: fileInfo,\n    }\n  })\n\n  const packages = (updateInfo as WindowsUpdateInfo).packages\n  const packageInfo = packages == null ? null : (packages[process.arch] || packages.ia32)\n  if (packageInfo != null) {\n    (result[0] as any).packageInfo = {\n      ...packageInfo,\n      path: newUrlFromBase(pathTransformer(packageInfo.path), baseUrl).href,\n    }\n  }\n  return result\n}"]}
