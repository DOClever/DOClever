{"version":3,"file":"DataSplitter.js","sourceRoot":"","sources":["../../src/differentialDownloader/DataSplitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { newError } from \"builder-util-runtime\"\nimport { createReadStream } from \"fs-extra-p\"\nimport { Writable } from \"stream\"\nimport { Operation, OperationKind } from \"./downloadPlanBuilder\"\n\nconst DOUBLE_CRLF = Buffer.from(\"\\r\\n\\r\\n\")\n\nenum ReadState {\n  INIT, HEADER, BODY\n}\n\nexport interface PartListDataTask {\n  readonly oldFileFd: number\n  readonly tasks: Array<Operation>\n  readonly start: number\n  readonly end: number\n}\n\nexport function copyData(task: Operation, out: Writable, oldFileFd: number, reject: (error: Error) => void, resolve: () => void) {\n  const readStream = createReadStream(\"\", {\n    fd: oldFileFd,\n    autoClose: false,\n    start: task.start,\n    // end is inclusive\n    end: task.end - 1,\n  })\n  readStream.on(\"error\", reject)\n  readStream.once(\"end\", resolve)\n  readStream.pipe(out, {\n    end: false\n  })\n}\n\nexport class DataSplitter extends Writable {\n  partIndex = -1\n\n  private headerListBuffer: Buffer | null = null\n  private readState = ReadState.INIT\n  private ignoreByteCount = 0\n  private remainingPartDataCount = 0\n\n  private readonly boundaryLength: number\n\n  constructor(private readonly out: Writable, private readonly options: PartListDataTask, private readonly partIndexToTaskIndex: Map<number, number>, boundary: string, private readonly partIndexToLength: Array<number>, private readonly finishHandler: () => any) {\n    super()\n\n    this.boundaryLength = boundary.length + 4 /* size of \\r\\n-- */\n    // first chunk doesn't start with \\r\\n\n    this.ignoreByteCount = this.boundaryLength - 2\n  }\n\n  get isFinished() {\n    return this.partIndex === this.partIndexToLength.length\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  _write(data: Buffer, encoding: string, callback: (error?: Error) => void) {\n    if (this.isFinished) {\n      console.error(`Trailing ignored data: ${data.length} bytes`)\n      return\n    }\n\n    this.handleData(data)\n      .then(callback)\n      .catch(callback)\n  }\n\n  private async handleData(chunk: Buffer): Promise<undefined> {\n    let start = 0\n\n    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {\n      throw newError(\"Internal error\", \"ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH\")\n    }\n\n    if (this.ignoreByteCount > 0) {\n      const toIgnore = Math.min(this.ignoreByteCount, chunk.length)\n      this.ignoreByteCount -= toIgnore\n      start = toIgnore\n    }\n    else if (this.remainingPartDataCount > 0) {\n      const toRead = Math.min(this.remainingPartDataCount, chunk.length)\n      this.remainingPartDataCount -= toRead\n      await this.processPartData(chunk, 0, toRead)\n      start = toRead\n    }\n\n    if (start === chunk.length) {\n      return\n    }\n\n    if (this.readState === ReadState.HEADER) {\n      const headerListEnd = this.searchHeaderListEnd(chunk, start)\n      if (headerListEnd === -1) {\n        return\n      }\n\n      start = headerListEnd\n      this.readState = ReadState.BODY\n      // header list is ignored, we don't need it\n      this.headerListBuffer = null\n    }\n\n    while (true) {\n      if (this.readState === ReadState.BODY) {\n        this.readState = ReadState.INIT\n      }\n      else {\n        this.partIndex++\n\n        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex)\n        if (taskIndex == null) {\n          if (this.isFinished) {\n            taskIndex = this.options.end\n          }\n          else {\n            throw newError(\"taskIndex is null\", \"ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL\")\n          }\n        }\n\n        const prevTaskIndex = this.partIndex === 0 ? this.options.start : (this.partIndexToTaskIndex.get(this.partIndex - 1)!! + 1 /* prev part is download, next maybe copy */)\n        if (prevTaskIndex < taskIndex) {\n          await this.copyExistingData(prevTaskIndex, taskIndex)\n        }\n        else if (prevTaskIndex > taskIndex) {\n          throw newError(\"prevTaskIndex must be < taskIndex\", \"ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED\")\n        }\n\n        if (this.isFinished) {\n          this.onPartEnd()\n          this.finishHandler()\n          return\n        }\n\n        start = this.searchHeaderListEnd(chunk, start)\n\n        if (start === -1) {\n          this.readState = ReadState.HEADER\n          return\n        }\n      }\n\n      const partLength = this.partIndexToLength[this.partIndex]\n      const end = start + partLength\n      const effectiveEnd = Math.min(end, chunk.length)\n      await this.processPartStarted(chunk, start, effectiveEnd)\n      this.remainingPartDataCount = partLength - (effectiveEnd - start)\n      if (this.remainingPartDataCount > 0) {\n        return\n      }\n\n      start = end + this.boundaryLength\n      if (start >= chunk.length) {\n        this.ignoreByteCount = this.boundaryLength - (chunk.length - end)\n        return\n      }\n    }\n  }\n\n  private copyExistingData(index: number, end: number) {\n    return new Promise((resolve, reject) => {\n      const w = () => {\n        if (index === end) {\n          resolve()\n          return\n        }\n\n        const task = this.options.tasks[index]\n        if (task.kind !== OperationKind.COPY) {\n          reject(new Error(\"Task kind must be COPY\"))\n          return\n        }\n\n        copyData(task, this.out, this.options.oldFileFd, reject, () => {\n          index++\n          w()\n        })\n      }\n      w()\n    })\n  }\n\n  private searchHeaderListEnd(chunk: Buffer, readOffset: number): number {\n    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset)\n    if (headerListEnd !== -1) {\n      return headerListEnd + DOUBLE_CRLF.length\n    }\n\n    // not all headers data were received, save to buffer\n    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset)\n    if (this.headerListBuffer == null) {\n      this.headerListBuffer = partialChunk\n    }\n    else {\n      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk])\n    }\n    return -1\n  }\n\n  private actualPartLength = 0\n\n  private onPartEnd() {\n    const expectedLength = this.partIndexToLength[this.partIndex - 1]\n    if (this.actualPartLength !== expectedLength) {\n      throw newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, \"ERR_DATA_SPLITTER_LENGTH_MISMATCH\")\n    }\n    this.actualPartLength = 0\n  }\n\n  private processPartStarted(data: Buffer, start: number, end: number): Promise<void> {\n    if (this.partIndex !== 0) {\n      this.onPartEnd()\n    }\n    return this.processPartData(data, start, end)\n  }\n\n  private processPartData(data: Buffer, start: number, end: number): Promise<void> {\n    this.actualPartLength += end - start\n    const out = this.out\n    if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {\n      return Promise.resolve()\n    }\n    else {\n      return new Promise((resolve, reject) => {\n        out.on(\"error\", reject)\n        out.once(\"drain\", () => {\n          out.removeListener(\"error\", reject)\n          resolve()\n        })\n      })\n    }\n  }\n}"]}
